
## Essential Docker Commands
 - `docker build` Build an image from a Dockerfile
 - `docker run` Create and run a new container from an image
 - `docker ps` List containers
 - `docker start` Start one or more stopped containers
 - `docker stop` Stop one or more running containers
 - `docker rm` Remove one or more containers
 - `docker rmi` Remove one or more images
 - `docker image` Manage images
 - `docker images` Lists all images stored locally
 - `docker pull` Downloads an image or a repository from a registry
 - `docker push` Uploads an image or a repository to a registry
 - `docker login` Authenticates to a Docker registry
 - `docker logout` Logs out from a Docker registry.
 - `docker exec` Runs a command in a running container
 - `docker logs` Fetches the logs of a container
 - `docker network` Manages networks
 - `docker volume` Manages volumes. Volumes are used to persist data generated by and used by Docker containers

---
 
 ### `docker build`
 Builds a Docker image from a Dockerfile. A Dockerfile contains a set of instructions for creating an image that includes the application, its dependencies, and runtime environments.

 `docker build [OPTIONS] PATH | URL`
  - `PATH` specifies the location of the Dockerfile and related context (e.g., files used in the build).
  - `URL` can be used to specify a Git repository as the source of the Dockerfile and context.
  - **Optional parameters**
    - `-t`, `--tag`: Name and optionally a tag in the 'name:tag' format
    - `--build-arg` Set build-time variables
    - `--no-cache` Do not use cache when building the image.
    - `-f, --file` Name of the Dockerfile (Default is PATH/Dockerfile).

**Examples:**
 - `docker build -t {image name} -f Dockerfile .` - build image with name
 - `docker build -t {image name}:{tag} --no-cache --build-arg {arguments like - ENVIRONMENT=production} -f Dockerfile .` - build image with name, arguments and no cache during building

---

### `docker run`
 Creates a new container from a specified image and starts it. If the image is not available locally, Docker will attempt to pull it from the configured registry.

 `docker run [OPTIONS] IMAGE [COMMAND] [ARG...]`
  - `IMAGE` is the name of the image to start the container from.
  - `COMMAND` and ARG specify the command to run inside the container.
  - **Optional parameters**
    - `-d, --detach` Run container in background and print container ID.
    - `--name` Assign a custom name to the container. If not specified, Docker generates a random name.
    - `-p, --publish` Publish a container's port(s) to the host. Format: hostPort:containerPort.
    - `-e, --env` Set environment variables. Format: VARIABLE=value.
    - `--rm` Automatically remove the container when it exits. This is useful for not leaving behind any stopped containers.
    - `-v, --volume` Mount a volume. Format: hostSrc:containerDest or just the volume name if using Docker volumes.

**Examples:**
 - `docker run --name {container name} {image name}` - start a container from an image
 - `docker run -d --name {container name} {image name}` - start a container in the background
 - `docker run -e ENVIRONMENT=production --name {container name} {image name}` - start a container with an environment variable

---

 ### `docker ps`
 Lists containers. By default, it shows only running containers.

`docker ps [OPTIONS]`

**Optional parameters**
 - `-a, --all`: Show all containers (default shows just running).
 - `-q, --quiet`: Only display container IDs.
 - `-f, --filter`: Filter the output based on conditions like status, id, name, etc.

**Examples:**
 - `docker ps` - List running containers.
 - `docker ps -a` - List all containers, including those that are stopped.
 - `docker ps -q` - List the IDs of all running containers.

---

### `docker start`
Starts one or more containers.

`docker start [OPTIONS] CONTAINER [CONTAINER...]`

- **CONTAINER**: The container ID or name. You can specify multiple containers to start.

**Optional parameters**
 - `-a, --attach`: Attach STDOUT/STDERR and forward signals.
 - `-i, --interactive`: Attach container's STDIN.

**Examples:**
 - `docker start {container name or ID}` - Start a stopped container.
 - `docker start -a {container name or ID}` - Start a stopped container and attach to it.
 - `docker start -i {container name or ID}` - Start a stopped container and attach STDIN, along with STDOUT/STDERR.

---

### `docker stop`
Stops one or more running containers.

`docker stop [OPTIONS] CONTAINER [CONTAINER...]`

- **CONTAINER**: The container ID or name. You can specify multiple containers to stop.

**Examples:**
- `docker stop {container name or ID}` - Stop a running container.
- `docker stop $(docker ps -q)` - Stop all running containers by passing the IDs of all running containers.

---

### `docker rm`
Removes one or more containers.

`docker rm [OPTIONS] CONTAINER [CONTAINER...]`

- **Optional parameters**
 - `-f, --force`: Force the removal of a running container (uses SIGKILL).
 - `-v, --volumes`: Remove the associated volumes with the container.

**Examples:**
 - `docker rm {container name or ID}` - Remove a stopped container.
 - `docker rm -f $(docker ps -a -q)` - Forcefully remove all containers, including running ones.

---

### `docker rmi`
Removes one or more images from the local storage. This command is used to manage the disk space by cleaning up unused images.

`docker rmi [OPTIONS] IMAGE [IMAGE...]`

- **IMAGE**: The image ID, repository, or tag. You can specify multiple images to remove.

**Optional parameters**
- `-f, --force`: Force removal of the image, even if it's being used by stopped containers or has dependent child images.
- `--no-prune`: Do not remove untagged parents.

**Examples:**
- `docker rmi {image ID or repository:tag}` - Remove a specific image by its ID or name and tag.
- `docker rmi -f {image ID}` - Forcefully remove an image, even if it is being used.
- `docker rmi $(docker images -q)` - Remove all images by passing the IDs of all images.

---



## Dockerfile
In summary, this Dockerfile defines a multi-stage build process where the first stage builds the .NET application, and the second stage prepares a lighter runtime environment to run the application.

```docker
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build-env
WORKDIR /App

COPY . ./

RUN dotnet restore

RUN dotnet publish -c Release -o out

FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /App
COPY --from=build-env /App/out .
ENTRYPOINT ["dotnet", "{service name}.dll"]
```

`FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build-env` - This line is telling Docker to use the .NET SDK version 8.0 image from Microsoft's Container Registry as the base image for the build process.
  - `Container Registry` - Storage for container images. In the context of this file: It is Microsoft's own container registry designed to provide a globally available service for pulling Microsoft's container images.
  - `AS build-env` - Set a name to this stage to use it later like a variable.

`WORKDIR /App` - Sets the working directory inside the container to /App. This is the directory where your application's code will reside within the container during the build process.

`COPY . ./` - Copies everything from your project's folder (where the Dockerfile is located) into the current working directory inside the container (*/App*).

`RUN dotnet restore` - Executes the dotnet restore command. This command looks at the .NET project files in the container and downloads any dependencies (*libraries and packages*) that are needed to build the project.

`RUN dotnet publish -c Release -o out` - This command builds your .NET application in release mode (*optimized for production*) and outputs the compiled files to the *out* directory within the */App* directory in the container.
 - `-c Release` - The -c Release option specifies that the build should be done in Release configuration, which is optimized for performance.

`FROM mcr.microsoft.com/dotnet/aspnet:8.0` - After building the application, this line starts a new stage in the Dockerfile. It uses the .NET runtime image (*not the SDK*) version 8.0 as the base image. This image is lighter than the SDK image and is suitable for running the application but not for building it.

`WORKDIR /App` - Sets the working directory in this new stage (runtime stage) to */App*, similar to what was done in the build stage.

`COPY --from=build-env /App/out .` - Copies the compiled application from the out directory of the build-env (*the first stage*) to the current working directory (*/App*) of the current stage. This means we are transferring only the necessary files needed to run the application, leaving behind the source code, SDK, and any other unnecessary files.

`ENTRYPOINT ["dotnet", "{service name}.dll"]` - Specifies the command to run when the container starts. This is the main assembly that was compiled and published in the previous steps.
